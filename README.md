Этот репозиторий содержит решения лабораторных работ по дисциплине "Технологии программирования" в Санкт-Петербургском политехническом университете Петра Великого.

В рамках лабораторных работ не допускается использование `std::stringstream`. Для реализации модульных тестов допустимо использовать любые шаблоны и классы стандартной библиотеки.

- **Язык:** C++
- **Технологии:** STL, OOP, Smart Pointers (RAII), Functors & Binders.

---

1. [Геометрические фигуры](#1-геометрические-фигуры) [`T1`](T1)
2. [Алгоритмы](#2-алгоритмы) [`T2`](T2)
3. [Код Хаффмана](#3-код-хаффмана) [`FT`](FT)

---

### 1. Геометрические фигуры

Все числовые данные в этой работе должны быть представлены значениями с плавающей запятой. Использование контейнеров стандартной библиотеки в настоящей работе недопустимо (за исключением `std::string` для обработки ввода).

1.  Создать файл `base-types.hpp`, содержащий определения следующих структур:
    *   `point_t`, представляющую собой точку на плоскости, координаты должны храниться в полях `x` и `y`.
    *   `rectangle_t`, описывающую прямоугольник шириной `width` и высотой `height` с центром в точке `pos`.

2.  Создать файл `shape.hpp`, содержащий определение абстрактного класса `Shape`. Этот класс должен предоставлять следующие методы:
    *   **getArea** вычисление площади.
    *   **getFrameRect** получение ограничивающего прямоугольника для фигуры (см. типы из предыдущего пункта), стороны ограничивающего прямоугольника всегда параллельны осям.
    *   **move** перемещение центра фигуры, 2 варианта: в конкретную точку и в виде смещений по осям абсцисс и ординат.
    *   **scale** изотропное масштабирование фигуры относительно её центра с указанным коэффициентом.

3.  Реализовать класс `Rectangle` в файлах `rectangle.hpp` и `rectangle.cpp`, соответственно.

4.  Дополнительно реализовать ещё 2 (две) геометрические фигуры, указанные преподавателем.

   5.  Продемонстрировать правильную работу классов программой, демонстрирующей полиморфное применение классов. Использование контейнеров стандартной библиотеки в настоящей работе недопустимо. Управление памятью должно осуществляться с помощью умных указателей, предоставляемых стандартной библиотекой (см. `std::unique_ptr`, `std::shared_ptr` и `std::weak_ptr`).

       *   Программа должна быть реализована в виде 1-го исполняемого файла, не обрабатывающего параметры командной строки.
       *   Программа должна обрабатывать поток стандартного ввода, содержащий описание геометрических фигур. Каждая строка гарантированно содержит описание не более одной фигуры. Элементы в описании разделены ровно одним пробелом и гарантировано являются вещественными числами (за исключением названия фигур). Описание завершается командой масштабирования фигур. Пример описания:
           ```text
           CIRCLE 1.15 2.5 10.1
           RECTANGLE -5.9 -3.4 3.0 4.0
        
           SQUARE -1.55 -1.55 10.5
           TRIANGLE 1.3 2.2 3.2 5.0 10.0 -5.5
           POLYGON 1.3 2.2 3.2 5.0 10.0 -5.5
        
           SCALE -15.0 -7.5 1.5
           ```

       *   Каждая фигура описывается своим набором параметров. Отсутствие самопересечений, выпуклость фигур и корректное количество параметров гарантируется, если не сказано иного:

           *   Прямоугольник описывается парой координат своих углов: левым нижним и правым верхним. Считайте, что стороны прямоугольника параллельны осям координат. Центром фигуры считайте точку пересечения диагоналей.
               ```text
               RECTANGLE 1.0 1.0 3.0 4.0
               RECTANGLE 0.0 0.0 -2.0 -10.0
               ```

           *   Круг описывается координатами центра и радиусом. Радиус должен быть положительным. Центром фигуры считайте центр окружности.
               ```text
               CIRCLE 2.0 3.0 15.0
               ```

           *   Кольцо описывается координатами центра и парой радиусов: внешней и внутренней окружности соответственно. Центром фигуры считайте центры окружностей.
               ```text
               RING 2.0 3.0 20.0 15.0
               ```

           *   Эллипс описывается координатами центра и двумя значениями радиусов: по вертикальной оси и по горизонтальной оси. Считайте, что оси эллипса параллельны осям координатам. Центром эллипса считайте точку пересечения осей эллипса.
               ```text
               ELLIPSE 0.0 0.0 10.0 20.0
               ```

           *   Квадрат описывается координатами своего левого нижнего угла и длиной стороны. Считайте, что стороны квадрата параллельны осям координат. Центром фигуры считайте точку пересечения диагоналей.
               ```text
               SQUARE 6.0 7.0 1.0
               ```

           *   Треугольник описывается координатами трёх своих вершин. Условия треугольника должны быть соблюдены. Центром фигуры считать центр тяжести фигуры.
               ```text
               TRIANGLE 0.0 0.0 1.0 1.0 0.0 1.0
               ```

           *   Параллелограмм описывается тремя вершинами, составляющими треугольник, одна из сторон которого является диагональю параллелограмма, а две другие — сторонами параллелограмма. Стороны параллелограмма формируются первой и последней парой вершин. При этом одна из сторон должна быть параллельна оси абсцисс. Центром фигуры считать точку пересечения диагоналей.
               ```text
               PARALLELOGRAM 0.0 1.0 10.0 1.0 5.0 0.0
               PARALLELOGRAM 0.0 1.0 10.0 1.0 5.0 5.0
               ```

           *   Ромб описывается тремя вершинами, составляющими треугольник, две стороны которого являются частью диагоналей ромба. Считайте, что диагонали ромба должны быть параллельны осям координат. Центром фигуры считайте точку пересечения диагоналей.
               ```text
               DIAMOND 0.0 5.0 10.0 0.0 0.0 0.0
               ```

           *   Правильный многоугольник задаётся тремя вершинами. Вершины должны соответствовать условиям треугольника и формировать прямоугольный треугольник, гипотенуза которого равна радиусу описанной у многоугольника окружности, а один из катетов - радиусу вписанной в многоугольник окружности. Считайте центром фигуры первую из трёх вершин.
               ```text
               REGULAR 0.0 0.0 0.0 1.0 1.0 1.0
               ```

           *   Полигон описывается координатам своих вершин. Центром фигуры считайте центр тяжести фигуры. При этом количество точек в описании должно быть достаточным для формирования полигона. Кроме того, никакие точки не должны совпадать.
               ```text
               POLYGON 0.0 0.0 1.0 0.0 1.0 1.0 0.0 1.0
               ```

           *   Невыпуклый четырёхугольник описывается четыремя вершинами. Первые три должны удовлетворять свойствам треугольника. Четвёртая вершина должна лежать внутри треугольника, формируемого первыми тремя вершинами. Вогнутость четырёхугольника формируется последними тремя вершинами в описании. Центром фигуры считайте точку, формирующую вогнутость.
               ```text
               CONCAVE 0.0 5.0 0.0 0.0 10.0 -1.0 1.0 1.0
               ```

           *   Четырёхугольник с самопересечениями задаётся координатами двух своих пересекающихся сторон. Центром фигуры считайте точку пересечения этих сторон. Кроме того, считайте, что первая и последняя вершины в описании формируют сторону фигуры.
               ```text
               COMPLEXQUAD 0.0 0.0 10.0 10.0 2.0 0.0 3.0 0.0
               ```

       *   Команда масштабирования содержит параметры изотропного масштабирования: по порядку координаты центра, относительно которого необходимо произвести масштабирование, и коэффициент масштабирования. Коэффициент должен быть положительным.

       *   После выполнения масштабирования в соответствии с указанными параметрами, программа должна вывести в стандартный вывод на отдельных строках:
           *   суммарную площадь и координаты ограничивающих прямоугольников обрабатываемых фигур в порядке их описания до масштабирования.
           *   суммарную площадь и координаты ограничивающих прямоугольников обрабатываемых фигур в порядке их описания после масштабирования.

           Элементы должны быть разделены ровно одним пробелом, содержать один и только один знак после запятой (округление проводить в соответствии с правилами математики) и описаны в следующем порядке.

       *   Пустые строки в описании фигур игнорируются.
       *   Описания фигур не реализованных в программе должны игнорироваться, как если бы строка была пустой.
       *   Если описание фигуры содержит ошибку, но её описание неверно, программа игнорирует её, но после масштабирования в стандартной поток ошибок должно выводиться сообщение о наличии ошибок в описании поддерживаемых фигур (конкретные фигуры указывать не требуется).
       *   Программа должна завершаться с сообщением об ошибке и ненулевым кодом возврата, если ввод завершился EOF (на Linux: `Ctrl + D` | на Windows: `Ctrl + Z` затем `Enter`), но команда масштабирования не описана или имеет некорректный коэффициент масштабирования.
       *   Описание каждого ограничивающего прямоугольника в выводе должно содержать по порядку координаты левого нижнего угла и координаты правого верхнего угла. Например для входных данных:

           ```text
           RECTANGLE -1.0 -1.0 1.0 1.0
           SQUARE -2.0 -2.0 4.0
           SQUARE -10.0 -5.0 -5.0
           SCALE 0.0 0.0 2.0
           ```

           *   Если фигура `SQUARE` не поддерживается программой, то в стандартный поток вывода должно быть выведено:
               ```text
               4.0 -1.0 -1.0 1.0 1.0
               16.0 -2.0 -2.0 2.0 2.0
               ```

           *   Если фигура `SQUARE` поддерживается программой, то в стандартный поток вывода должно быть выведено:
               ```text
               20.0 -1.0 -1.0 1.0 1.0 -2.0 -2.0 2.0 2.0
               80.0 -2.0 -2.0 2.0 2.0 -4.0 -4.0 4.0 4.0
               ```

           А в стандартный поток ошибок необходимо вывести сообщение о наличии некорректной фигуры. При этом код возврата должен быть нулевым.

---

### 2. Алгоритмы

Написать программу, которая выполняет следующие действия:

1.  Заполняет `std::vector< DataStruct >` структурами `DataStruct`, прочитанными со стандартного ввода. Чтение необходимо осуществлять с помощью итераторов и алгоритмов STL (`std::copy`, итераторы потока и перегрузки оператора побитового сдвига для чтения из потока).
2.  Сортирует считанные данные следующим образом:
    1. По возрастанию `key1`
    2. По возрастанию `key2`, если `key1` одинаковые
    3. По возрастанию длины строки `key3`, если прочие поля равны
3.  Выводит результаты сортировки на стандартный вывод. Каждая строка должна содержать ровно один объект. Формат каждого выводимого объекта аналогичен формату ввода. Вывод необходимо осуществлять с помощью итераторов и алгоритмов STL (`std::copy`, итераторов потока и перегрузки оператора побитового сдвига для вывода в поток).

Входные данные могут содержать строки с неподдерживаемым форматом данных. Такие строки должны игнорироваться. Формат данных, который необходимо обрабатывать зависит в том числе от определения `DataStruct`.

1.  Тип `DataStruct` определён следующим образом:
    ```cpp
    struct DataStruct
    {
        /* TYPE1 */ key1;
        /* TYPE2 */ key2;
        std::string key3;
    };
    ```
    Конкретные типы полей `key1` и `key2`, а также соответствующий полям формат должны быть указаны преподавателем.

2.  Каждая запись ограничена парой скобок. Внутри этих скобок в качестве разделителей используются пробельные символы и символы `:`. Например:
    ```text
    (:key1 10ull:key2 'c':key3 "Data":)
    ```

    Порядок описания полей в структуре не определён. Например следующие структуры данных считаются идентичными:
    ```text
    (:key1 10ull:key2 'c':key3 "Data":)
    (:key2 'c':key1 10ull:key3 "Data":)
    (:key3 "Data":key2 'c':key1 10ull:)
    ```
    Имя поля и соответствующее значение гарантировано разделены ровно одним пробелом. Символы двоеточия гарантировано примыкают к прочим элементам записи. При выводе в поток поля выводятся в том порядке, в котором они заданы в структуре (запоминать исходный порядок не требуется).

3.  Поля могут иметь следующий тип и соответствующий формат:

    *   `[DBL LIT]` Вещественное поле с двойной точностью (**double**) в формате литерала:
        ```text
        :keyX 50.0d:
        :keyX 50.0D:
        ```
    *   `[DBL SCI]`Вещественное поле с двойной точностью (**double**) в научном формате:
        ```text
        :keyX 5.45e-2:
        :keyX 5.45E-2:
        ```
        Число должно выводиться в стандартном виде, т.е мантисса должна быть меньше 10 и не меньше 1.
    *   `[SLL LIT]` Знаковое максимально доступной ёмкости (**long long**) в формате литерала:
        ```text
        :keyX 8911:
        :keyX -89LL:
        ```
    *   `[ULL LIT]` Беззнаковое максимально доступной ёмкости (**unsigned long long**) в формате литерала:
        ```text
        :keyX 89ull:
        :keyX 89ULL:
        ```
    *   `[ULL OCT]` Беззнаковое максимально доступной ёмкости (**unsigned long long**) в формате восьмеричного литерала:
        ```text
        :keyX 076:
        :keyX 01001:
        ```
    *   `[ULL BIN]` Беззнаковое максимально доступной ёмкости (**unsigned long long**) в формате двоичного литерала:
        ```text
        :keyX 0b1000101:
        :keyX 0B001001:
        ```
    *   `[ULL HEX]` Беззнаковое максимально доступной ёмкости (**unsigned long long**) в формате шестнадцатеричного литерала:
        ```text
        :keyX 0xFFFA:
        :keyX 0X0100f:
        ```
        Цифры шестнадцатеричного числа выводятся в верхнем регистре.
    *   `[CHR LIT]` Символ (**char**) в формате символьного литерала:
        ```text
        :keyX 'c':
        :keyX 'A':
        ```
    *   `[CMP LSP]` Комплексное число (`std::complex< `**double**` >`) в следующем виде:
        ```text
        :keyX #c(1.0 -1.0):
        :keyX #c(-1.0 1.0):
        ```
        Гарантируется, что вещественная и мнимая часть разделены ровно одним пробелом. При сравнении с другими полями должен быть использован модуль комплексного числа.
    *   `[RAT LSP]` Рациональное число (`std::pair< `**long long, unsigned long long**` >`) в следующем виде:
        ```text
        :keyX (:N -2:D 3:):
        :keyX (:N 3:D 2:):
        ```

    *   Если в качестве варианта задания выданы `[CMP LSP]` и `[RAT LSP]`, то `DataStruct` должна быть определена следующем образом:
        ```cpp
        struct DataStruct
        {
            std::complex< double > key1;
            std::pair< long long, unsigned long long > key2;
            std::string key3;
        };
        ```
        При этом обрабатываемые записи имеют следующий вид:
        ```text
        (:key1 #c(1.0 -1.0):key2 (:N -1:D 5:):key3 "data":)
        (:key2 (:N -1:D 5:):key3 "with : inside":key1 #c(2.0 -3.0):)
        ```

Все вещественные выводятся с точностью до десятичных долей. Символы, характерные для литералов выводятся в нижнем регистре (`1.1e+1, 1ull, 0b01, 0x0F`).

---

### 3. Код Хаффмана

#### Входные и выходные данные

Программа работает в режиме командной строки (читает поток `std::cin`).
Внутри программы доступен вектор строк (регистры данных) от `data0` до `data9`.

*   **Вход:** Текстовые команды, подаваемые на стандартный ввод, либо чтение из файлов через команду `read`.
*   **Выход:** Вывод в консоль через `print` или запись в файлы через команду `flush`.

Пример формата команд:
`command data<Index> [arguments]`

### Запуск

#### Интерактивный режим:
```bash
./huffman
```
После запуска можно вводить команды вручную. Для завершения используйте `Ctrl+D` (EOF).

#### Пакетный режим (из файла скрипта):
Если у вас есть файл `script.txt` с набором команд:
```bash
./huffman < script.txt
```

### Список команд

Ниже приведен список поддерживаемых команд, реализованных в `commands.cpp`.

*   **`read data<N> [filename]`** — Считывает строку в регистр `dataN`. Если `filename` указан, читает из файла, иначе ожидает ввод из консоли.
*   **`print data<N>`** — Выводит содержимое регистра `dataN` в консоль.
*   **`encode data<Dst> data<Src>`** — Кодирует текст из регистра `Src` по алгоритму Хаффмана и сохраняет результат (битовую строку) в регистр `Dst`.
*   **`flush data<N> [filename]`** — Записывает содержимое `dataN` в файл `filename`. Если файл не указан, выводит в консоль.
*   **`inspect data<N>`** — Проверяет содержимое `dataN`. Выводит `ENCODED`, если строка состоит только из '0' и '1', иначе `RAW`.
*   **`concat data<Dst> data<Src1> data<Src2>`** — Объединяет строки из `Src1` и `Src2`, записывая результат в `Dst`.
*   **`merge data<Dst> data<Src>`** — Условное объединение (специфичная логика проверки типов данных перед слиянием).
*   **`drop data<N>`** — Очищает содержимое регистра `dataN`.
*   **`equals data<N> data<M>`** — Сравнивает два регистра (результат внутренней логики, не выводит в консоль напрямую в текущей реализации).
*   **`list`** — Выводит список всех непустых регистров данных.

### Пример использования

Предположим, у вас есть файл `file.txt` с содержимым `aaabccdddd`.

Пример сессии:

```bash
# Читаем из файла input.txt в нулевой регистр
read data0 input.txt

# Кодируем данные из data0 и кладем результат в data1
encode data1 data0

# Проверяем статус данных
inspect data0
inspect data1

# Выводим закодированную строку
print data1

# Сохраняем результат в файл
flush data1 output.bin
```

### Структура проекта:

*   `main.cpp` — Точка входа, парсер команд и цикл обработки.
*   `commands.cpp / .h` — Реализация логики команд.
*   `Node.cpp / .h` — Структура узла дерева Хаффмана и логика построения дерева.